Iter::Able -- Adding abilities for iterables

** Synopsis
#+begin_src raku
use Iter::Able <take-while group-conseq>;

[2, 3, 19, 7, 44, 13, -1].&take-while(*.is-prime).raku.say;  # (2, 3, 19, 7).Seq

"until the first space".&take-while(/\S/).raku.say;          # "until"

[4, 4, 5, 4].&group-conseq.raku.say;                         # (4 => (4, 4), 5 => (5,), 4 => (4,)).Seq

(1, -1, 1, -1, 1, -1).&group-conseq(as => &abs).raku.say;    # (1 => (1, -1, 1, -1, 1, -1),).Seq

#+end_src

** Description
Provides iterable manipulation functions. Raku already has superb support for such tasks, e.g., =map=, =grep=, =rotor=, =categorize= etc. One can build more specific functions using them (implementation- and/or semantic-wise); this module aims to do that for variety of functions for reuse. Inspirations include [[https://github.com/magnars/dash.el][dash.el]] of ELisp, [[https://rubydoc.info/stdlib/core/Enumerable][Enumerable]] of Ruby, [[https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html][std::iter::Iterator]] of Rust, [[https://docs.python.org/3/library/itertools.html][itertools]] and [[https://more-itertools.readthedocs.io/en/stable/][more_itertools]] of Python.

*** =use=age
+ /No/ functions imported: =use Iter::Able;=
+ /All/ functions imported: =use Iter::Able *;= (or =<*>=)
+ Selective importing: =use Iter::Able <take-while skip-while>;=

All functions are our-scoped so they are reachable with their partially qualified names in any case, e.g., =Iter::Able::skip-while=.

*** Functions
# START-DOC
**** annotate =(\ist, &mapper = {$_})=
Generates (x, f(x)) lists. By default, f(x) = x.
#+begin_src raku
    # Mirrors the items by default
    >>> [-4, 3, 0].&annotate
    ((-4, -4), (3, 3), (0, 0))

    # Let items carry their length with them
    >>> ("piano", "drum", "violin").&annotate(&chars)
    (("piano", 5), ("drum", 4), ("violin", 6))

    # Originals and matches
    >>> ["this and that", "yes and no", "real"].&annotate(/ .? <before ' and'>/)
    (("this and that", ｢this｣), ("yes and no", ｢yes｣), ("real", Nil))

    # is-upper decoration
    >>> annotate "reAL", {$_ eq .uc}  # or `so * ~~ / <.upper> /``
    (("r", False), ("e", False), ("A", True), ("L", True))
#+end_src

**** assign-at =(\ist, *@pairs)=
Perform index-based replacement given index => new-value pairs.
#+begin_src raku
    # Replace what's at index 1
    >>> [0, 1, 2, 3].&assign-at(1 => -9)
    (0, -9, 2, 3)

    # Multiple index-value pairs are possible
    >>> [4, 3, 2, 1].&assign-at(0 => -4, 2 => -1)
    (-4, 3, -1, 1)

    # Out of bounds indexes are ignored
    >>> [5, 55, 555].&assign-at(3 => 5555)
    (5, 55, 555)

    # Strings are possible too
    >>> "past".&assign-at(0 => "q")
    "qast"

    # Empty string as the replacer removes
    >>> "until".&assign-at(1 => "")
    "util"

    # Can expand a string
    >>> "play".&assign-at(0 => "de")
    "delay"
#+end_src

**** chain =(\ist, **@iters)=
Yield from this iterable first; when exhausted, from next, and so on.
#+begin_src raku
    # Accepts any number of iterables
    >>> [-1, -2, -3].&chain([4, 5], [-6])
    (-1, -2, -3, 4, 5, -6)

    # Infinity chaining
    >>> [1, 2].&chain(3 xx *).head(5)
    (1, 2, 3, 3, 3)

    # Strings are accepted too
    >>> (4, 7).&chain("spa")
    (4, 7, "s", "p", "a")

    # Another way of (one-level) flattening a list of lists
    >>> chain |[[4, 7], [6], [0, 8, 9]]
    (4, 7, 6, 0, 8, 9)
#+end_src

**** clip =(\it, Numeric :$from-below, Numeric :$from-above)=
Limit the values from below and/or above.
#+begin_src raku
    # No negatives
    >>> [-1, 2, -3].&clip(from-below => 0)
    (0, 2, 0)

    # Accumulate everything to be in the first quadrant
    >>> (2 × rand - 1) xx 5 ==> map(*.acos.round(0.001)) ==> clip(from-below => 0, from-above => π / 2)
    (0.829 0.463 0.998 1.254 1.5707963267948966)

    # At most 100 is allowed
    >>> 3 <<**<< (4, 5, 6) ==> clip(:100from-above)
    (81, 100, 100)

#+end_src

**** cycle =(\ist)=
Repeat indefinitely.
#+begin_src raku
    >>> [1, 2, 3].&cycle.head(5)
    (1, 2, 3, 1, 2)

    >>> "real".&cycle.head(8)
    ("r", "e", "a", "l", "r", "e", "a", "l")
#+end_src

**** enumerate =(\ist, :$start = 0)=
Generates (index, element) lists, with the starting index specifiable.
#+begin_src raku
    # Default starts from 0
    >>> [1, 2, 3, 0].&enumerate
    ((0, 1), (1, 2), (2, 3), (3, 0))

    >>> "yes".&enumerate(start => 1)
    ((1, "y"), (2, "e"), (3, "s"))
#+end_src

**** flatten =(\it, :levels(:$level))=
Makes a "one dimensional" iterable. Unlike the built-in =flat=, does not respect itemized iterables. The number of levels to flatten can be controlled with the =:$level= parameter; currently leveled flattening reifies the iterable.
#+begin_src raku
    # Flatten all the way by default
    >>> flatten ((1, (2, 3)), (4, 5, 6), 7)
    (1, 2, 3, 4, 5, 6, 7)

    # Flatten only 1 level
    >>> ((1, (2, 3)), (4, 5, 6), 7).&flatten(:1level)
    (1, (2, 3), 4, 5, 6, 7)

    # Unlike `flat`, itemizeds are subject to flattenning
    >>> [(3, 4), 5, (6,)].&flatten
    (3, 4, 5, 6)

    # Ragged all the way
    >>> flatten [["a", ("b", "c")], [("d",), "e", "f", ["g", ("h", "i")]]]
    ("a", "b", "c", "d", "e", "f", "g", "h", "i")

    # Ragged up to 2 levels
    >>> flatten [["a", ("b", ("c", "d"))], [[[["e"],],],]], :2levels
    ["a", "b", ("c", "d"), [["e"],]]

#+end_src

**** group-conseq =(\ist, :&as = {$_}, :&with = &[===])=
Pack consecutive "same" elements together and yield "key => group" pairs where `group`s are Lists (values are not copied). Sameness can be controlled with a transformer (`as`) and/or an equality checker (`with`).
#+begin_src raku
    # Elements themselves are the groupers by default
    >>> [3, 4, 4, 5, 4].&group-conseq;
    (3 => (3,), 4 => (4, 4), 5 => (5,), 4 => (4,))

    # Group consecutive records together; any duplicate key might be anomaly
    >>> [("A", 1), ("B", 1), ("D", 2), ("E", 1)].&group-conseq(:as(*[1]));
    (1 => (("A", 1), ("B", 1)), 2 => (("D", 2),), 1 => (("E", 1),)

    # They are all the same, really
    >>> [1, -1, 1, -1, 1, -1].&group-conseq(as => &abs);
    (1 => (1 -1 1 -1 1 -1))

    # Respect the container for sameness
    >>> my $a = 7;
    >>> ($a, $a, 7).&group-conseq(with => &[=:=]);
    (7 => (7 7) 7 => (7))

    # Case insensitive detection of consecutive duplicates in a string; typos?
    >>> my $s = "how aree youU?";
    >>> $s.&group-conseq(as => &lc).grep(*.value > 1)
    (e => (e e) u => (u U))
#+end_src

**** map-first =(\ist, &pred, &mapper)=
Map only the first item matching the predicate, if any.
#+begin_src raku
    # First positive to negative
    >>> map-first [1, 2, 3], * > 0, -*
    (-1, 2, 3)

    # Can use with all-pass filter to assign to head :)
    >>> map-first ["", 5, 9, 11], { True }, { 0 }
    (0, 5, 9, 11)

    # First uppercase to lowercase
    >>> "here WE are".&map-first(/ <.upper> /, &lc)
    "here wE are"

    # If noone matches, everyone is yielded as is
    >>> [4, 44, 444, 4444].&map-first(*.is-prime, { 7 });
    (4, 44, 444, 4444)
#+end_src

**** map-indexed =(\ist, &mapper = {@_.List}, :$start = 0)=
Maps the iterable given the index and the element, i.e., `-> $idx, $val { ... }` is the mapper. By default `index` starts from 0 but can be changed with `:$start`.
#+begin_src raku
    # Produce new items as `index * element`
    >>> [3, 2, 1].&map-indexed(* * *)
    (0, 2, 2)

    # `index + element` as kind of an added ramp and also start from 1
    >>> (4, 7, 12, -3).&map-indexed(* + *, start => 1)
    (5, 9, 16, 1)

    # Even indexed values are zeroed out
    >>> (4, 7, -1).&cycle.&map-indexed({ $^idx %% 2 ?? 0 !! $^val }).head(5)
    (0, 7, 0, 4, 0)

    # Repeat a character as many as its position suggests
    >>> "train".&map-indexed(* Rx *, start => 1)
    ("t", "rr", "aaa", "iiii", "nnnnn")
#+end_src

**** map-last =(\ist, &pred, &mapper)=
Map only the last item matching the predicate, if any.
#+begin_src raku
    # Last negative to positive
    >>> map-last [2, -3, 4, -6, 8], * < 0, -*
    (2, -3, 4, 6, 8)

    # Can use with all-pass filter to change the last element :)
    >>> map-last [3, 4, 7, NaN], { True }, { -1 }
    (3, 4, 7, -1)

    # Last lowercase to uppercase
    >>> "here we are!".&map-last(/ <.lower> /, &uc)
    "here we arE!"

    # If noone matches, everyone is yielded as is
    >>> [57, 91, -13].&map-last(*.is-prime, { 0 });
    (57, 91, -13)
#+end_src

**** map-when =(\ist, &pred, &mapper)=
If an element satisfies the predicate, transform it; else, keep as is.
#+begin_src raku
    # If nonpositive, make it cubed
    >>> [1, -2, 3, 0, 4, -5].&map-when(* <= 0, * ** 3)
    (1, -8, 3, 0, 4, -125)

    # Take the square root only if positive
    >>> (4, -7, 9, 0).&map-when(* > 0, &sqrt)
    (2, -7, 3, 0)

    # Make vowels upper case
    >>> "mixed feelings".&map-when(/:i <[aeiou]>/, &uc).raku
    "mIxEd fEElIngs"

    # Normalize "anomalies"
    >>> (r1 => 7.13, r2 => 6.89, r3 => 7.90, r4 => 6.61).&map-when((*.value - 7).abs >= 0.2, {7})
    (r1 => 7.13, r2 => 6.89, r3 => 7, r4 => 7)
#+end_src

**** replace =(\it, *@pairs)=
Translates values by looking up in the given pairs. All occurences are replaced. Only Numerics and Strings are replaced; for others, see =map-when=. For replacing strings, see the built-in =trans=.
#+begin_src raku
    # Replace a single value
    >>> [1, 2, 3].&replace(2 => 99)
    (1, 99, 3)

    # More than one
    >>> (4, 5, 6, 5, 4).&replace((4, 5) X=> 0)
    (0, 0, 6, 0, 0)

    # Need to quote the LHS of pairs if they are valid identifiers,
    # as they would pass as named arguments otherwise
    >>> ["yes", "no", "both"].&replace("both" => "neither")
    ["yes", "no", "neither"]

    # Unfound LHS values of pairs are silently ignored
    >>> [2, 4, 6, 7].&replace(8 => -8)
    (2, 4, 6, 7)
#+end_src

**** skip-while =(\ist, &pred = {$_})=
Skip (drop) values from the iterable as long as `&pred` holds; once not, start taking values indefinitely.
#+begin_src raku
    # Truthfulness of elements decide to skip or start taking by default
    >>> [4, 8, -1, "", 7, Any, 5, 0].&skip-while.raku
    ("", 7, Any, 5, 0).Seq

    # Skip the falseful ones instead
    >>> [0, "", 7, Any, 4, -5].&skip-while(&not).raku
    (7, Any, 4, -5).Seq

    # Generalized trim-leading
    >>> (NaN, NaN, NaN, 4.6, -7.1, 8.0).&skip-while(* === NaN)
    (4.6 -7.1 8)
#+end_src

**** take-while =(\ist, &pred = {$_})=
Take values from the iterable as long as `&pred` holds; once not, stop.
#+begin_src raku
    # Truthfulness of elements decide take or stop by default
    >>> [1, 2, 3, 0, 4, 5].&take-while
    (1 2 3)

    # Negative value is a sentinel, so take up until that
    >>> (4, 7, 12, -3, 58, 0, 102).&take-while(* >= 0)
    (4 7 12)

    # Until first whitespace
    >>> "until first whitespace".&take-while(/ \S /).raku
    "until"

    # Go till an "anomaly" occurs
    >>> (r1 => 7.13, r2 => 6.89, r3 => 7.90, r4 => 6.81).&take-while((*.value - 7).abs <= 0.2)
    (r1 => 7.13 r2 => 6.89)
#+end_src
# END-DOC

# ** Contribution
# For a new function, there are "module.template" and "tester.template" in tools/; "make-new-fun.raku" is also there and generates a rakumod and a rakutest file for the new function in appropriate directories. Rest is filling in the blanks. Let's say for adding "intersperse" functionality, after forking:

# #+begin_src shell
# $ git clone git@github.com:<your-username>/Iter-Able.git
# $ cd Iter-Able
# $ git checkout -b intersperse
# $ raku tools/make-new-fun.raku
# #+end_src

# "lib/Iter/Able/Intersperse.rakumod" and "t/0x-intersperse.rakutest" are generated and filled in with some boilerplate.

** License
This library is free software; you can redistribute it and/or modify it under the [[https://directory.fsf.org/wiki/License:Artistic-2.0][Artistic License 2.0]].